identify_and_transform_variable_types <- function(df) {
# Assurer que le data frame est bien un data frame
df <- as.data.frame(df)
# Transformation des colonnes
df <- df %>%
mutate(across(everything(), ~ {
if (is.character(.) && length(unique(.)) < 5) {
as.factor(.)  # Transforme en facteur pour les variables avec moins de 5 modalités
} else {
.  # Laisse inchangée les autres colonnes
}
}))
# Afficher un aperçu après transformation
message("After transformation:")
print(head(df))
return(df)
}
df <- identify_and_transform_variable_types(df)
glimpse(df)
dummy_variables <- function(df) {
# Nettoyer les noms de colonnes (enlever accents, espaces, etc.)
names(df) <- gsub(" ", "_", names(df)) # Remplacer les espaces par des underscores
names(df) <- iconv(names(df), from = "UTF-8", to = "ASCII//TRANSLIT") # Enlever les accents
names(df) <- make.names(names(df)) # S'assurer que les noms sont valides
# Identifier les colonnes factorielles
factor_columns <- sapply(df, is.factor)
if (any(factor_columns)) {
# Créer un modèle de dummification
dummy_model <- dummyVars(~ ., data = df[, factor_columns, drop = FALSE])
# Générer les variables dummy
dummy_data <- predict(dummy_model, newdata = df[, factor_columns, drop = FALSE])
# Convertir les données dummy en data frame
dummy_data <- as.data.frame(dummy_data)
# Supprimer les colonnes factorielles originales
df <- df[, !factor_columns]
# Ajouter les variables dummy créées au data frame original
df <- cbind(df, dummy_data)
# Afficher un aperçu des données après transformation
message("")
print(head(df))
} else {
message("")
}
return(df)
}
df <- dummy_variables(df)
colnames(df) <- make.unique(colnames(df))
df <- df %>% select(-Nom)
head__ <- head(df)
library(kableExtra)
kable(head__, format = "html", escape = FALSE) %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left") %>%
column_spec(1, width = "5em", extra_css = "font-size: 8px;") %>%
column_spec(2, width = "5em", extra_css = "font-size: 8px;") %>%
row_spec(0, font_size = 8) %>%
kable_styling(html_font = "monospace") %>%
scroll_box(height = "50%", width = "100%")
library(ggplot2)
library(dplyr)
library(reshape2)
analyze_bivariate <- function(df) {
# Nettoyer les noms de colonnes (enlever accents, espaces, etc.)
names(df) <- gsub(" ", "_", names(df)) # Remplacer les espaces par des underscores
names(df) <- iconv(names(df), from = "UTF-8", to = "ASCII//TRANSLIT") # Enlever les accents
names(df) <- make.names(names(df)) # S'assurer que les noms sont valides
numeric_cols <- names(df)[sapply(df, is.numeric)]
factor_cols <- names(df)[sapply(df, is.factor)]
# Heatmap pour la matrice de corrélation
if (length(numeric_cols) > 1) {
corr_matrix <- cor(df[numeric_cols], use = "complete.obs", method = "pearson")
corr_melt <- melt(corr_matrix)
heatmap_plot <- ggplot(corr_melt, aes(Var1, Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1, 1)) +
labs(title = "Heatmap des corrélations", x = "", y = "") +
theme_minimal()
print(heatmap_plot)
}
}
# Lancer l'analyse
analyze_bivariate(df)
# Suppression des espaces, des accents, et création de noms valides
clean_column_names <- function(df) {
# Remplacer les espaces par des underscores
names(df) <- gsub(" ", "_", names(df))
# Supprimer les accents et convertir en caractères ASCII
names(df) <- iconv(names(df), from = "UTF-8", to = "ASCII//TRANSLIT")
# Créer des noms valides en R
names(df) <- make.names(names(df), unique = TRUE)
# Optionnel : Convertir en minuscules pour uniformiser
names(df) <- tolower(names(df))
return(df)
}
# Appliquer la fonction à votre dataframe
df <- clean_column_names(df)
library(caret)
library(randomForest)
library(rpart)
library(e1071)
library(glmnet)
# Prétraitement des données
# Créer la variable cible (Target)
df$Target <- apply(df[, c("resultats_des_tests.anormal",
"resultats_des_tests.non_concluant",
"resultats_des_tests.normal")],
1, function(row) {
# Retourner l'indice de la colonne avec la valeur 1, sinon NA
match <- which(row == 1)
if (length(match) == 1) {
return(match)
} else {
return(NA)  # Assigner NA si aucune colonne ou plusieurs colonnes valent 1
}
})
# Vérification et transformation en facteur
df$Target <- as.factor(df$Target)
# Supprimer les colonnes inutiles
df <- df[, !colnames(df) %in% c("resultats_des_tests.anormal",
"resultats_des_tests.non_concluant",
"resultats_des_tests.normal")]
library(caret)
library(MLmetrics)
# Balancement des classes avec stratification
# Identifier la classe minoritaire
class_counts <- table(df$Target)
min_class_count <- min(class_counts)
# Sous-échantillonnage stratifié basé sur la classe minoritaire
df_balanced <- df %>%
group_by(Target) %>%
sample_n(min_class_count) %>%
ungroup()
# Vérification des proportions après le balancement
table(df_balanced$Target)
# Renommer les niveaux de la variable Target pour qu'ils soient valides
levels(df_balanced$Target) <- make.names(levels(df_balanced$Target))
# Vérifiez les nouveaux niveaux
levels(df_balanced$Target)
# Contrôle de l'entraînement avec validation croisée
control <- trainControl(
method = "cv", # Validation croisée
number = 2, # Augmentez le nombre de folds pour de meilleures estimations
search = "grid",
verboseIter = TRUE,
classProbs = TRUE, # Assurer le calcul des probabilités de classe
summaryFunction = multiClassSummary, # Fonction pour évaluer les classes
sampling = "smote" # Ajouter SMOTE pour traiter les déséquilibres
)
# Paramètres de la grille pour Random Forest
grid_rf <- expand.grid(mtry = c(2, 4))
# Modèle Random Forest
rf_model <- train(
Target ~ .,
data = df_balanced,
method = "rf",
metric = "Accuracy",
tuneGrid = grid_rf,
trControl = control
)
library(caret)
library(randomForest)
library(rpart)
library(e1071)
library(glmnet)
# Plage pour cp
grid_dt <- expand.grid(cp = seq(0.01, 0.1, by = 0.01))  # Ajuster la plage de cp
control <- trainControl(
method = "cv", # Validation croisée
number = 2, # Augmentez le nombre de folds pour de meilleures estimations
search = "grid",
verboseIter = TRUE,
classProbs = TRUE, # Assurer le calcul des probabilités de classe
summaryFunction = multiClassSummary, # Fonction pour évaluer les classes
sampling = "smote" # Ajouter SMOTE pour traiter les déséquilibres
)
# Decisions Trees
dt_model <- train(Target ~ .,
data = df_balanced,
method = "rpart",
metric = "Accuracy",
tuneGrid = grid_dt,
trControl = control)
# Résultats
dt_model <- na.omit(dt_model)
grid_svm <- expand.grid(C = c(0.1, 1, 10))  # Paramètre de coût pour SVM
# SVM
svm_model <- train(Target ~ ., data = df_balanced, method = "svmLinear",
metric = "Accuracy", tuneGrid = grid_svm,
trControl = control)
print(svm_model)
grid_lr <- expand.grid(alpha = 0, lambda = seq(0.001, 0.1, by = 0.01))  # Paramètres pour la régression Ridge
# Régression logistique (Ridge)
lr_model <- train(Target ~ ., data = df_balanced, method = "glmnet",
metric = "Accuracy", tuneGrid = grid_lr,
trControl = control)
print(lr_model)
# KNN
grid_knn <- expand.grid(k = c(3, 5, 7))
knn_model <- train(Target ~ ., data = df_balanced, method = "knn",
metric = "Accuracy", tuneGrid = grid_knn,
trControl = control)
print(knn_model)
# Comparaison des performances
results <- resamples(list(RandomForest = rf_model,
DecisionTree = dt_model,
SVM = svm_model,
LogisticRegression = lr_model,
KNN = knn_model))
# Résumé des performances
result_summary <- summary(results)
suppressPackageStartupMessages(library(pROC))
# Prédictions pour chaque modèle
pred_rf <- predict(rf_model, type = "prob")
pred_dt <- predict(dt_model, type = "prob")
pred_svm <- predict(svm_model, type = "prob")
pred_lr <- predict(lr_model, type = "prob")
pred_knn <- predict(knn_model, type = "prob")
# Assurez-vous que les classes cibles sont bien définies
levels(df_balanced$Target)
# Liste pour stocker les courbes ROC
roc_curves_rf <- list()
roc_curves_dt <- list()
roc_curves_svm <- list()
roc_curves_lr <- list()
roc_curves_knn <- list()
# Calcul des courbes ROC pour chaque modèle en capturant les avertissements
for (class in levels(df_balanced$Target)) {
binary_labels <- as.numeric(df_balanced$Target == class)
# Capturer les avertissements et ne pas les afficher
capture.output({
roc_curves_rf[[class]] <- roc(binary_labels, pred_rf[, class])
roc_curves_dt[[class]] <- roc(binary_labels, pred_dt[, class])
roc_curves_svm[[class]] <- roc(binary_labels, pred_svm[, class])
roc_curves_lr[[class]] <- roc(binary_labels, pred_lr[, class])
roc_curves_knn[[class]] <- roc(binary_labels, pred_knn[, class])
}, file = NULL)  # Le paramètre `file = NULL` évite de sauvegarder la sortie dans un fichier
}
# Tracer les courbes ROC
plot(roc_curves_rf[[1]], col = "red", main = "Comparaison des courbes ROC pour différents modèles",
xlim = c(0, 1), ylim = c(0, 1), lwd = 2)
lines(roc_curves_dt[[1]], col = "blue", lwd = 2)
lines(roc_curves_svm[[1]], col = "green", lwd = 2)
lines(roc_curves_lr[[1]], col = "purple", lwd = 2)
lines(roc_curves_knn[[1]], col = "orange", lwd = 2)
# Ajouter les autres classes dans le même graphique
for (i in 2:length(levels(df_balanced$Target))) {
lines(roc_curves_rf[[i]], col = "red", lwd = 2, lty = i)
lines(roc_curves_dt[[i]], col = "blue", lwd = 2, lty = i)
lines(roc_curves_svm[[i]], col = "green", lwd = 2, lty = i)
lines(roc_curves_lr[[i]], col = "purple", lwd = 2, lty = i)
lines(roc_curves_knn[[i]], col = "orange", lwd = 2, lty = i)
}
# Ajouter une légende
legend("bottomright", legend = c("Random Forest", "Decision Tree", "SVM", "Logistic Regression", "KNN"),
col = c("red", "blue", "green", "purple", "orange"), lwd = 2, lty = 1, cex = 0.8)
suppressPackageStartupMessages(library(pROC))
# Prédictions pour chaque modèle
pred_rf <- predict(rf_model, type = "prob")
pred_dt <- predict(dt_model, type = "prob")
pred_svm <- predict(svm_model, type = "prob")
pred_lr <- predict(lr_model, type = "prob")
pred_knn <- predict(knn_model, type = "prob")
# Assurez-vous que les classes cibles sont bien définies
levels(df_balanced$Target)
# Liste pour stocker les courbes ROC
roc_curves_rf <- list()
roc_curves_dt <- list()
roc_curves_svm <- list()
roc_curves_lr <- list()
roc_curves_knn <- list()
# Calcul des courbes ROC pour chaque modèle en capturant les avertissements
for (class in levels(df_balanced$Target)) {
binary_labels <- as.numeric(df_balanced$Target == class)
# Capturer les avertissements et ne pas les afficher
capture.output({
roc_curves_rf[[class]] <- roc(binary_labels, pred_rf[, class])
roc_curves_dt[[class]] <- roc(binary_labels, pred_dt[, class])
roc_curves_svm[[class]] <- roc(binary_labels, pred_svm[, class])
roc_curves_lr[[class]] <- roc(binary_labels, pred_lr[, class])
roc_curves_knn[[class]] <- roc(binary_labels, pred_knn[, class])
}, file = NULL)  # Le paramètre `file = NULL` évite de sauvegarder la sortie dans un fichier
}
# Tracer les courbes ROC
plot(roc_curves_rf[[1]], col = "red", main = "Comparaison des courbes ROC pour différents modèles",
xlim = c(0, 1), ylim = c(0, 1), lwd = 2)
lines(roc_curves_dt[[1]], col = "blue", lwd = 2)
lines(roc_curves_svm[[1]], col = "green", lwd = 2)
lines(roc_curves_lr[[1]], col = "purple", lwd = 2)
lines(roc_curves_knn[[1]], col = "orange", lwd = 2)
# Ajouter les autres classes dans le même graphique
for (i in 2:length(levels(df_balanced$Target))) {
lines(roc_curves_rf[[i]], col = "red", lwd = 2, lty = i)
lines(roc_curves_dt[[i]], col = "blue", lwd = 2, lty = i)
lines(roc_curves_svm[[i]], col = "green", lwd = 2, lty = i)
lines(roc_curves_lr[[i]], col = "purple", lwd = 2, lty = i)
lines(roc_curves_knn[[i]], col = "orange", lwd = 2, lty = i)
}
# Ajouter une légende
legend("bottomright", legend = c("Random Forest", "Decision Tree", "SVM", "Logistic Regression", "KNN"),
col = c("red", "blue", "green", "purple", "orange"), lwd = 2, lty = 1, cex = 0.8)
rlang::last_trace()
rsconnect::accounts()
intall.packages('rsconnect')
install.packages("rsconnect")
install.packages("shiny")
install.packages("rsconnect")
rsconnect::setAccountInfo(name='hamadygackou',
token='DBD31E93AA98946C3E007DE54CE9209C',
secret='8vtZC3tdAkQBcxqnsph1CjP+EDcdyyJWzi8YIXjd')
rsconnect::setAccountInfo(name='hamadygackou',
token='DBD31E93AA98946C3E007DE54CE9209C',
secret='8vtZC3tdAkQBcxqnsph1CjP+EDcdyyJWzi8YIXjd')
rsconnect::accounts()
rsconnect::setAccountInfo(name='hamadygackou',
token='DBD31E93AA98946C3E007DE54CE9209C',
secret='8vtZC3tdAkQBcxqnsph1CjP+EDcdyyJWzi8YIXjd')
rsconnect::accounts()
rsconnect::deployApp(appDir = "C:/Users/MLSD/Desktop/System_Project/ProjetProgrammationWeb/report_original.", account = "hamadygackou")
file.exists("C:/Users/MLSD/Desktop/System_Project/ProjetProgrammationWeb/report_original")
file.exists("/report_original")
file.exists("../report_original")
getwd()
ls
list()
list.files()
file.exists("/report_original.html")
file.exists("report_original.html")
rsconnect::deployApp(appDir = "C:/Users/MLSD/Desktop/System_Project/ProjetProgrammationWeb/report_original.html", account = "hamadygackou")
rsconnect::deployApp(report_original.html", account = "hamadygackou")
rsconnect::deployApp("report_original.html", account = "hamadygackou")
rsconnect::deployApp("report_original.Rmd", account = "hamadygackou")
shiny::runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp()
runApp('app')
runApp('app')
runApp('app')
shiny::runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
shiny::runApp('app')
# Chargement des bibliothèques nécessaires
set.seed(120)  # Pour la reproductibilité
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(shiny))
suppressPackageStartupMessages(library(rsconnect))
# Liste des valeurs possibles pour certaines colonnes
genders <- c("Homme", "Femme")
blood_types <- c("A+", "A-", "B+", "B-", "O+", "O-", "AB+", "AB-")
medical_conditions <- c("Diabète", "Hypertension", "Asthme", "Cancer", "Maladies cardiaques", "Anémie")
doctors <- c("Dr. Smith", "Dr. Johnson", "Dr. Williams", "Dr. Brown", "Dr. Jones")
hospitals <- c("Hôpital A", "Hôpital B", "Hôpital C", "Hôpital D")
insurance_providers <- c("Aetna", "Blue Cross", "Cigna", "UnitedHealthcare", "Medicare")
medications <- c("Aspirine", "Ibuprofène", "Pénicilline", "Paracétamol", "Lipitor")
test_results <- c("Normal", "Anormal", "Non_concluant")
# Fonction pour générer les données synthétiques
generate_data <- function(num_records) {
data <- data.frame(
Nom = replicate(num_records, paste0(sample(letters, 10, replace = TRUE), collapse = "")),
Age = sample(13:89, num_records, replace = TRUE),
Sexe = sample(genders, num_records, replace = TRUE),
Groupe_sanguin = sample(blood_types, num_records, replace = TRUE),
Etat_medical = sample(medical_conditions, num_records, replace = TRUE),
Date_d_admission = sample(seq(as.Date("2010-01-01"), as.Date("2024-01-01"), by="day"), num_records, replace = TRUE),
Medecin = sample(doctors, num_records, replace = TRUE),
Hopital = sample(hospitals, num_records, replace = TRUE),
Fournisseur_d_assurance = sample(insurance_providers, num_records, replace = TRUE),
Montant_facture = round(runif(num_records, min = 1000, max = 50000), 2),
Numero_de_chambre = sample(101:500, num_records, replace = TRUE),
Type_d_admission = sample(c("Urgence", "Électif", "Urgent"), num_records, replace = TRUE),
Date_de_sortie = sample(seq(as.Date("2010-01-01"), as.Date("2024-01-01"), by="day"), num_records, replace = TRUE),
Medicament = sample(medications, num_records, replace = TRUE),
Resultats_des_tests = sample(test_results, num_records, replace = TRUE)
)
return(data)
}
# Générer 10 000 lignes de données
num_records <- 10000
df <- generate_data(num_records)
# Introduction de valeurs manquantes de manière aléatoire dans certaines colonnes
set_missing_values <- function(df, missing_rate = 0.05) {
num_rows <- nrow(df)
num_missing <- floor(num_rows * missing_rate)
# Colonnes où les valeurs peuvent être manquantes
cols_with_missing <- c("Etat_medical", "Date_d_admission", "Numero_de_chambre", "Montant_facture")
for (col in cols_with_missing) {
missing_indices <- sample(1:num_rows, num_missing)
df[missing_indices, col] <- NA
}
return(df)
}
df <- set_missing_values(df, missing_rate = 0.05)
# Introduction d'outliers dans la colonne 'Montant_facturé'
introduce_outliers <- function(df, outlier_rate = 0.02) {
num_rows <- nrow(df)
num_outliers <- floor(num_rows * outlier_rate)
# Sélection de quelques indices pour les outliers
outlier_indices <- sample(1:num_rows, num_outliers)
df$Montant_facture[outlier_indices] <- df$Montant_facture[outlier_indices] * 10  # Valeurs aberrantes
return(df)
}
df <- introduce_outliers(df, outlier_rate = 0.02)
# Déséquilibre des classes dans la colonne 'État_médical'
introduce_class_imbalance <- function(df) {
state_imbalance <- c("Normal" = 0.7, "Anormal" = 0.2, "Non_concluant" = 0.1)
df$Resultats_des_tests <- sample(names(state_imbalance), nrow(df), replace = TRUE, prob = state_imbalance)
return(df)
}
df <- introduce_class_imbalance(df)
# Afficher un résumé du dataset
summary(df)
# Chargement des bibliothèques nécessaires
set.seed(120)  # Pour la reproductibilité
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(shiny))
suppressPackageStartupMessages(library(rsconnect))
# Liste des valeurs possibles pour certaines colonnes
genders <- c("Homme", "Femme")
blood_types <- c("A+", "A-", "B+", "B-", "O+", "O-", "AB+", "AB-")
medical_conditions <- c("Diabète", "Hypertension", "Asthme", "Cancer", "Maladies cardiaques", "Anémie")
doctors <- c("Dr. Smith", "Dr. Johnson", "Dr. Williams", "Dr. Brown", "Dr. Jones")
hospitals <- c("Hôpital A", "Hôpital B", "Hôpital C", "Hôpital D")
insurance_providers <- c("Aetna", "Blue Cross", "Cigna", "UnitedHealthcare", "Medicare")
medications <- c("Aspirine", "Ibuprofène", "Pénicilline", "Paracétamol", "Lipitor")
test_results <- c("Normal", "Anormal", "Non_concluant")
# Fonction pour générer les données synthétiques
generate_data <- function(num_records) {
data <- data.frame(
Nom = replicate(num_records, paste0(sample(letters, 10, replace = TRUE), collapse = "")),
Age = sample(13:89, num_records, replace = TRUE),
Sexe = sample(genders, num_records, replace = TRUE),
Groupe_sanguin = sample(blood_types, num_records, replace = TRUE),
Etat_medical = sample(medical_conditions, num_records, replace = TRUE),
Date_d_admission = sample(seq(as.Date("2010-01-01"), as.Date("2024-01-01"), by="day"), num_records, replace = TRUE),
Medecin = sample(doctors, num_records, replace = TRUE),
Hopital = sample(hospitals, num_records, replace = TRUE),
Fournisseur_d_assurance = sample(insurance_providers, num_records, replace = TRUE),
Montant_facture = round(runif(num_records, min = 1000, max = 50000), 2),
Numero_de_chambre = sample(101:500, num_records, replace = TRUE),
Type_d_admission = sample(c("Urgence", "Électif", "Urgent"), num_records, replace = TRUE),
Date_de_sortie = sample(seq(as.Date("2010-01-01"), as.Date("2024-01-01"), by="day"), num_records, replace = TRUE),
Medicament = sample(medications, num_records, replace = TRUE),
Resultats_des_tests = sample(test_results, num_records, replace = TRUE)
)
return(data)
}
# Générer 10 000 lignes de données
num_records <- 1000
df <- generate_data(num_records)
# Introduction de valeurs manquantes de manière aléatoire dans certaines colonnes
set_missing_values <- function(df, missing_rate = 0.05) {
num_rows <- nrow(df)
num_missing <- floor(num_rows * missing_rate)
# Colonnes où les valeurs peuvent être manquantes
cols_with_missing <- c("Etat_medical", "Date_d_admission", "Numero_de_chambre", "Montant_facture")
for (col in cols_with_missing) {
missing_indices <- sample(1:num_rows, num_missing)
df[missing_indices, col] <- NA
}
return(df)
}
df <- set_missing_values(df, missing_rate = 0.05)
# Introduction d'outliers dans la colonne 'Montant_facturé'
introduce_outliers <- function(df, outlier_rate = 0.02) {
num_rows <- nrow(df)
num_outliers <- floor(num_rows * outlier_rate)
# Sélection de quelques indices pour les outliers
outlier_indices <- sample(1:num_rows, num_outliers)
df$Montant_facture[outlier_indices] <- df$Montant_facture[outlier_indices] * 10  # Valeurs aberrantes
return(df)
}
df <- introduce_outliers(df, outlier_rate = 0.02)
# Déséquilibre des classes dans la colonne 'État_médical'
introduce_class_imbalance <- function(df) {
state_imbalance <- c("Normal" = 0.7, "Anormal" = 0.2, "Non_concluant" = 0.1)
df$Resultats_des_tests <- sample(names(state_imbalance), nrow(df), replace = TRUE, prob = state_imbalance)
return(df)
}
df <- introduce_class_imbalance(df)
# Afficher un résumé du dataset
summary(df)
runApp('app')
shiny::runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
runApp('app')
shiny::runApp('app')
